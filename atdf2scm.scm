;; [AVR Tools Device Files](https://packs.download.microchip.com/) are
;; XML descriptions of a selectio of microcontrollers. They describe
;; memory regions and various other things. They are officialy
;; provided by Microchip. We use these to generate code to expose
;; register addresses and hopefully, a nice API for target
;; exploration.
;;
;; This script tries to turn a ATDF XML file into a Scheme program. I
;; wish to commit these files, even though they are generated, in
;; order to simplify build steps, track changes and avoid XML parsing
;; internally.
;;
;; TODO: check address-space=data
;; TODO: output device signature somewhere
;;
;; > chicken-install ssax
;; > cat Microchip.ATtiny_DFP.3.0.151/atdf/ATtiny414.atdf | csi -s atdf2scm.scm > atdf/ATtiny414.atdf.scm
(import ssax chicken.string chicken.port)

(define (string-pad s n char)
  (if (>= n 0)
      (string-append   (make-string (max 0 (- (+ n) (string-length s))) char) s)
      (string-append s (make-string (max 0 (- (- n) (string-length s))) char))))

(define (string->number* s) ;; (string->number* "0x100")
  (if (substring=? s "0x" 0 0 2)
      (string->number (string-append "#x" (substring s 2)) 16)
      (string->number s 10)))

(define updi? #f)

(print ";; generated by atdf2scm.scm, do not edit")

(define registers '())

((ssax:make-parser
  NEW-LEVEL-SEED
  (lambda (elem-gi att ns expected-content seed)
    (let* ((placement      (car seed))
           (modules        (cadr seed))
           (current-module (caddr seed))

           (placement (cons elem-gi placement))

           ;; (_ (print "Â» " (reverse placement)))

           ;; each module has registers and their offsets. there can
           ;; be multiple instances of the same module. each instance
           ;; has an absolute address from which the module offsets
           ;; are based.
           (modules (if (equal? placement (reverse '(avr-tools-device-file devices device peripherals
                                                                           module instance register-group)))
                        (let* ((offset    (string->number* (alist-ref 'offset att)))
                               (module    (alist-ref 'name-in-module att)) ;; eg AC
                               (instance  (alist-ref 'name           att)) ;; eg AC0 (instance of module)
                               (instances (alist-ref module modules equal? '()))
                               (entry     (list instance offset)))
                          (alist-update module (cons entry instances) modules))
                        modules))

           ;; track which module we're in so we can find its registers
           ;; when we encounter an instance.
           (current-module
            (if (equal? placement (reverse '(avr-tools-device-file modules module register-group )))
                (let ((name (alist-ref 'name att)))
                  name)
                current-module))

           (_
            (when (equal? placement (reverse '(avr-tools-device-file modules module
                                                                     register-group register)))
              (let* ((register (alist-ref 'name att))
                     (offset-register (string->number* (alist-ref 'offset att))))
                (map
                 (lambda (pair)
                   (let* ((instance (car pair))
                          (offset-module (cadr pair)))
                     (set! registers
                           (cons (list instance register (+ offset-module offset-register))
                                 registers))))
                 (alist-ref current-module modules equal?)))))

           (_ (when (equal? placement (reverse '(avr-tools-device-file devices device interfaces interface)))
                (and (equal? "UPDI" (alist-ref 'name att))
                     (set! updi? #t)))))
      (list placement modules current-module)))

  FINISH-ELEMENT
  (lambda (elem-gi att ns parent-seed seed)
    (let ((parent-placement (car parent-seed)))
      (cons parent-placement (cdr seed))))

  CHAR-DATA-HANDLER
  (lambda (string1 string2 seed)
    seed))
 (current-input-port) '(() () #f '()))

(for-each
 (lambda (spec)
   (apply
    (lambda (instance register addr)
      (let ((variable (conc instance "." register))
            (addr* (conc "#x" (string-pad (number->string addr 16) 4 #\0))))
        (print "(define " (string-pad variable -20 #\space)
               " (register " (string-pad (conc "'" variable) -20 #\space) " " addr* ")"
               ")")))
    spec))
 registers)

(unless updi?
  (with-output-to-port (current-error-port)
    (lambda ()
      (print "atdf2scm: device does not appear to be a UPDI device")
      (exit 2))))
