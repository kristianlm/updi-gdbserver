
* AVR UPDI library and cli tool


Only the ATTiny414 is currently supported.

Use [[https://sourceware.org/gdb/][avr-gdb]] to debug your AVR programs. Follow the ordinary pymcuprog
guidance for how to get the serial port set up to talk
UPDI. [[https://github.com/SpenceKonde/AVR-Guidance/blob/master/UPDI/jtag2updi.md][AVR-Guidance]] has a nice ascii diagram:

#+begin_src
--------------------                                   To Target device
                DTR|    470Ω    BAT43                 __________________
                Rx |---------------------,-----------| UPDI
                Tx |----/\/\-----|<|----'       ,----| Gnd
                Vcc|---------------------------/-----| Vcc
                CTS|                          /      |__________________
                Gnd|-------------------------'
-----------
#+end_src

You can also see [[https://github.com/microchip-pic-avr-tools/pymcuprog#serial-port-updi-pyupdi][Serial port UPDI]] or for details.

** Building

Unfortunately, this tool is written in an exoteric language and has
unusual build steps. Try this:

#+begin_src bash
  > apt install chicken-bin # or pacman -S chicken or something thereof
  > git clone https://github.com/kristianlm/updi-gdbserver
  > cd updi-gdbserver
  > csc -O1 gdbserver.scm
  > # TODO: chicken-install -s -test && gdbserver instead
#+end_src

** Running ~avr-gdb~

With ~./gdbserver~ running, if the stars are aligned, you might be
able to do something this:

#+begin_src ruby
   > avr-gcc -DF_CPU=4000000 -O1 -g -mmcu=attiny414 example-led-blink.c -o example-led-blink.elf
   > avr-gdb --eval-command "target remote 127.0.0.1:4444" example-led-blink.elf
  GNU gdb (GDB) 12.1
  …
  Reading symbols from example-led-blink.elf...
  Remote debugging using 127.0.0.1:4444
  0x00000002 in __vectors ()
  (gdb) load                    # <-- upload program to flash (resets target)
  Loading section .text, size 0x86 lma 0x0
  Start address 0x00000000, load size 134
  Transfer rate: 509 bytes/sec, 26 bytes/write.
  (gdb) c                       # <-- pin starts to toggle
  Continuing.
  ^C
  Program stopped.              # <-- progam stops, pin toggling stops
  0x00000076 in main () at /usr/avr/include/util/delay.h:187
  187		__builtin_avr_delay_cycles(__ticks_dc);
  (gdb) bt
  #0  0x00000076 in main () at /usr/avr/include/util/delay.h:187
  (gdb) print *(char*)0x0404    # <-- value of PORTA.OUT (why doesn't gdb have it?)
  $1 = 0 '\000'                 # <-- pin was low on break
  (gdb) c
  Continuing.
  ^C                            # <-- stopping program again when pin was high
  Program stopped.
  0x0000005e in main () at /usr/avr/include/util/delay.h:187
  187		__builtin_avr_delay_cycles(__ticks_dc);
  (gdb) print *(char*)0x0404
  $2 = 64 '@'                   # <-- pin 6 high, as seen on scope!
  (gdb) set *(char*)0x0404 = 0  # <-- watch pin 6 go back low
  (gdb) set *(char*)0x0404 = 64 # <-- and back up
#+end_src

** REPL

There is also a Scheme REPL available where you can experiment. I find
it useful to poke at peripheral registers interactively from a REPL
environment before I start writing any code meant to run on the
target. Below is an example of using the DAC peripheral while the
target CPU is stopped.

#+begin_src scheme
  me@workstation> rlwrap nc localhost 1234
  ;; nrepl on (./gdbserver)
  #> (updi-break)
  #> (stop!)
  #> (set! (VREF.CTRLA) 1) ;; 1.1V
  #> (set! (DAC.CTRLA)  #b01000001) ;; OUTEN, ENABLE
  #> (set! (PORTA.OUT)  #b01000000) ;; PA6 output
  #> (define (dac n) (set! (DAC.DATA) n))
  #> (begin (dac #x80) (dac #xff) (dac #x80) (dac #x00))
#+end_src

This should produce a scope trace like this:

[[./images/scope-dac.png]]

The DAC output is shown in purple, and the rather slow UPDI UART
communication is shown in blue. The delays between the ~dac~ calls are
caused by UART communication. This could probably be improved by
investigating at guard time and UPDI clock speed.

** TODOs

Too many to mention here, the source contains a lot of them. But a few
important ones:

- Support multiple hardware breakpoints

- Comunnicate memory regions to GDB somehow. Currently, avr-gdb will
  upload flash content 32B at a time. With a 64B flash pagesize, this
  wears the flash twice as it needs to.

- Detect target device automatically (based on the 24-bit signature)

- registers: track bitfields and pretty-print

- Find out what register ~#x0f90~ is for (stores opcode?) Can we run
  arbitrary instructions on the target CPU from there?

- Support (gdb) info io_registers

- Integrate with chicken-debugwire? If the API can be generalized.

- EEPROM support?

- Many, many more.
