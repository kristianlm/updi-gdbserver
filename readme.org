
* AVR UPDI library and cli tool


Only the ATTiny414 is currently supported.

Use [[https://sourceware.org/gdb/][avr-gdb]] to debug your AVR programs. Follow the ordinary pymcuprog
guidance for how to get the serial port set up to talk
UPDI. [[https://github.com/SpenceKonde/AVR-Guidance/blob/master/UPDI/jtag2updi.md][AVR-Guidance]] has a nice ascii diagram:

#+begin_src
--------------------                                   To Target device
                DTR|    470Ω    BAT43                 __________________
                Rx |---------------------,-----------| UPDI
                Tx |----/\/\-----|<|----'       ,----| Gnd
                Vcc|---------------------------/-----| Vcc
                CTS|                          /      |__________________
                Gnd|-------------------------'
-----------
#+end_src

You can also see [[https://github.com/microchip-pic-avr-tools/pymcuprog#serial-port-updi-pyupdi][Serial port UPDI]] or for details.

** Building

Unfortunately, this tool is written in an exoteric language and has
unusual build steps. Try this:

#+begin_src bash
  > apt install chicken-bin # or pacman -S chicken or something thereof
  > git clone https://github.com/kristianlm/updi-gdbserver
  > cd updi-gdbserver
  > csc -O1 gdbserver.scm
  > # TODO: chicken-install -s -test && gdbserver instead
#+end_src

** Running ~avr-gdb~

With ~./gdbserver~ running and the stars aligned, you might be able to
do something this:

#+begin_src C
  > avr-gcc -DF_CPU=1000000 -Os -g -mmcu=attiny414 example-led-blink.c -o example-led-blink.elf
  > avr-gdb --eval-command "target remote 127.0.0.1:4444" --eval-command "load" example-led-blink.elf
  GNU gdb (GDB) 12.1
  …
  Reading symbols from example-led-blink.elf...
  Remote debugging using 127.0.0.1:4444
  0x00000000 in __vectors ()
  Loading section .text, size 0x7e lma 0x0
  Start address 0x00000000, load size 126
  Transfer rate: 88 bytes/sec, 42 bytes/write.
  (gdb) print $pc
  $1 = (void (*)()) 0x0 <__vectors>
  (gdb) monitor (reset!)
  #<unspecified>
  (gdb) hbreak example-led-blink.c:7
  Hardware assisted breakpoint 1 at 0x4c: file example-led-blink.c, line 7.
  (gdb) i br
  Num     Type           Disp Enb Address    What
  1       hw breakpoint  keep y   0x0000004c in main at example-led-blink.c:7
  (gdb) c
  Continuing.

  Breakpoint 1, main () at example-led-blink.c:7
  7	    PORTA.OUT |=  (1 << PIN6_bp); _delay_ms(100);
  (gdb) c
  Continuing.

  Breakpoint 1, main () at example-led-blink.c:7
  7	    PORTA.OUT |=  (1 << PIN6_bp); _delay_ms(100);
#+end_src

** REPL

There is also a Scheme REPL available where you can experiment. I find
it useful to poke at peripheral registers interactively from a REPL
environment before I start writing any code meant to run on the
target. Below is an example of using the DAC peripheral while the
target CPU is stopped.

#+begin_src scheme
  me@workstation> rlwrap nc localhost 1234
  ;; nrepl on (./gdbserver)
  #> (updi-break)
  #> (stop!)
  #> (set! (VREF.CTRLA) 1) ;; 1.1V
  #> (set! (DAC.CTRLA)  #b01000001) ;; OUTEN, ENABLE
  #> (set! (PORTA.OUT)  #b01000000) ;; PA6 output
  #> (define (dac n) (set! (DAC.DATA) n))
  #> (begin (dac #x80) (dac #xff) (dac #x80) (dac #x00))
#+end_src

This should produce a scope trace like this:

[[./images/scope-dac.png]]

The DAC output is shown in purple, and the rather slow UPDI UART
communication is shown in blue. The delays between the ~dac~ calls are
caused by UART communication. This could probably be improved by
investigating at guard time and UPDI clock speed.

** TODOs

Too many to mention here, the source contains a lot of them. But a few
important ones:

- Support multiple hardware breakpoints

- Comunnicate memory regions to GDB somehow. Currently, avr-gdb will
  upload flash content 32B at a time. With a 64B flash pagesize, this
  wears the flash twice as it needs to.

- Detect target device automatically (based on the 24-bit signature)

- registers: track bitfields and pretty-print

- Find out what register ~#x0f90~ is for (stores opcode?) Can we run
  arbitrary instructions on the target CPU from there?

- Support (gdb) info io_registers

- Integrate with chicken-debugwire? If the API can be generalized.

- EEPROM support?

- Monitor for wdt reset and inform gdb (SIGILL?)

- fix: PORTB is gone!

- Many, many more.
