
* AVR UPDI library and cli tool


Only the ATTiny414 is currently supported.

Use [[https://sourceware.org/gdb/][avr-gdb]] to debug your AVR programs. Follow the ordinary pymcuprog
guidance for how to get the serial port set up to talk UPDI. Something
like this.

#+begin_src
--------------------                                   To Target device
                DTR|    470Î©    BAT43                 __________________
                Rx |---------------------,-----------| UPDI
                Tx |----/\/\-----|<|----'       ,----| Gnd
                Vcc|---------------------------/-----| Vcc
                CTS|                          /      |__________________
                Gnd|-------------------------'
-----------
#+end_src

 See [[https://github.com/microchip-pic-avr-tools/pymcuprog#serial-port-updi-pyupdi][Serial port UPDI]] or [[https://github.com/SpenceKonde/AVR-Guidance/blob/master/UPDI/jtag2updi.md][AVR-Guidance]] for more details.

** Building

Unfortunately, this tool is written in an exoteric language and has
unusual build steps. Try this:

#+begin_src bash
  > apt install chicken-bin # or pacman -S chicken or something thereof
  > git clone https://github.com/kristianlm/updi-gdbserver
  > cd updi-gdbserver
  > csc -O1 gdbserver.scm
  > # TODO: chicken-install -s -test && gdbserver instead
#+end_src

** Running

With ~./gdbserver~ running, if the stars are aligned, you might be
able to do this:

#+begin_src
> ~/profiles/avr/bin/avr-gdb -ex "target extended-remote 127.0.0.1:4444" main.elf
Reading symbols from main.elf...
Remote debugging using 127.0.0.1:4444
0x0000007a in main () at /home/klm/profiles/avr/avr/include/util/delay.h:187
187 __builtin_avr_delay_cycles(__ticks_dc);
(gdb) bt
#0  0x0000007a in main () at /home/klm/profiles/avr/avr/include/util/delay.h:187
(gdb) c
Continuing.
^C
Program stopped.
0x00000078 in main () at /home/klm/profiles/avr/avr/include/util/delay.h:187
187 __builtin_avr_delay_cycles(__ticks_dc);
(gdb) print *(char*)0x0404
$1 = 0 '\000'                                       <--- that's PORTA.OUT @ pin 5
(gdb) c
Continuing.
^C                                              <-- that's me pressing C-c after a bit. I can see the pin toggle on my scope, but only while it's "continuing"
Program stopped.
0x00000060 in main () at /home/klm/profiles/avr/avr/include/util/delay.h:187
187 __builtin_avr_delay_cycles(__ticks_dc);
(gdb) print *(char*)0x0404                   <-- pin has gone high meanwhile
$2 = 32 ' '
(gdb) p $pc
$3 = (void (*)()) 0x60 <main+26>
(gdb) # when we update main.elf. we can program the flash (which will also reset the target)
(gdb) load
Loading section .text, size 0x88 lma 0x0
Start address 0x00000000, load size 136
Transfer rate: 521 bytes/sec, 27 bytes/write.
#+end_src

** REPL

There is also a Scheme REPL available where you can experiment. I find
it useful to poke at peripheral registers interactively from a REPL
environment before I start writing any code meant to run on the
target. Below is an example of using the DAC peripheral while the
target CPU is stopped (and thus independent of any

#+begin_src scheme
  me@workstation> rlwrap nc localhost 1234
  ;; nrepl on (./gdbserver)
  #;> (set! (VREF.CTRLA) 1) ;; 1.1V
  #;> (set! (DAC.CTRLA)  #b01000001) ;; OUTEN, ENABLE
  #;> (set! (PORTA.OUT)  #b01000000) ;; PA6 output
  #;> (define (dac n) (set! (DAC.DATA) n))
  #;> (begin (dac #x80) (dac #xff) (dac #x80) (dac #x00))
#+end_src

This should produce a scope trace like this:

[[./images/scope-dac.png]]

The DAC output is shown in purple, and the rather slow UPDI UART
communication is shown in blue. The delays between the ~dac~ calls are
caused by UART communication. This could probably be improved by
investigating at guard time and UPDI clock speed.

** TODO

Too many to mention here, the source contains a lot of them. But a few
important ones:

- Setting breakpoints ("Z", "z")

- Comunnicate memory regions to GDB somehow. Currently, avr-gdb will
  upload flash content 32B at a time. With a 64B flash pagesize, this
  wears the flash twice as it needs to.

- Support (gdb) info io_registers
